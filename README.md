# 202030223 이강현
학교 React1 과목 공부한 내용들
<br><br>

## 2023.04.13 7주차<br>
1. 1교시
> * ### 7.1 훅이란 무엇인가?
>   * 클래스형 컴포넌트에서는 생성자(constructor)에서 state를 정의하고, setState() 함수를 통해 state를 업데이트한다.
>   * 예전에 사용하던 함수형 컴포넌트는 별도로 state를 정의하거나, 컴포넌트의 생명주기에 맟춰서 어떤 코드가 실행되도록 할 수 없었다.
>   * 함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 바로 훅(Hook)이다.
>   * 함수형 컴포넌트도 훅을 사용하여 클래스형 컴포넌트의 기능을 모두 통일하게 구현할 수 있게 되었다.
>   * Hook이란 'state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 함수'를 의미한다
>   * 훅의 이름은 모두 'use'로 시작한다.
>   * 사용자 정의 훅(custom hook)을 만들 수 있으며, 이 경우에 이름은 자유롭게 할 수있으나 'use'로 시작을 해야한다.
> * ### 7.2 useState
>   * useState는 함수형 컴포넌트에서 state를 사용하기 위한 Hook이다.
>   * 다음 예제는 버튼을 클릭 할 때마다 카운트가 증가하는 함수형 컴포넌트다.
>   * 하지만 증가는 시킬 수 있지만 증가할 때마다 재 렌더링은 일어나지 않는다.
>   * 이럴 때 state를 사용해야 하지만 함수형에는 없기 때문에 useState()를 사용한다.
```javascript
import React, { useState } from "react";

function Counter(props) {
    var count = 0;

    return(
        <div>
            <p>총 {count}번 클릭했습니다.</p>
            <button onClick={() => count++}>
                클릭
            </button>
        </div>
    )
}
```
>   * 첫번째 항목은 state의 이름(변수명)이다.
>   * 두번째 항목은 state의 set함수이다. 즉 state를 업데이트 하는 함수다.
>   * 함수를 호출 할 때 state의 초기값을 설정한다.
>   * 함수의 리턴 값은 배열의 형태다
```javascript
import React, { useState } from "react";

function Counter(props) {
    const [count, setCount] = useState(0);

    return(
        <div>
            <p>총 {count}번 클릭했습니다.</p>
            <button onClick={() => setCount(count + 1)}>
                클릭
            </button>
        </div>
    );
}
```
> * ### 7.3 useEffect
>   * useState와 함께 가장 많이 사용하는 Hook이다.
>   * 이 함수는 사이드 이펙트를 수행하기 위한 것이다.
>   * 영어로 side effect는 부작용을 의미한다. 일반적으로 프로그래밍에서 사이트 이펙트는 '개발자가 의도하지 않은 코드가 실행되면서 버그가 발생하는 것'을 말한다.
>   * 하지만 리액트에서는 효과 또는 영향을 뜻하는 effect의 의미에 가깝다.
>   * 예를 들면 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업을 의미한다.
>   * 이 작업을 이펙트라고 부르는 이유는 이 작업들이 다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료 될 수 없기 때문이다. 랜더링이 끝난 이후에 실행되어야 하는 작업들이다.
>   * 클래스 컴포넌트의 생명주기 함수와 같은 기능을 하나로 통합한 기능을 제공한다.
>   * useEffect가 side effect가 아니라 effect에 가깝다고 설명하고 있지만, 이 것은 부작용의 의미를 잘못 해석해서 생긴 오해다. 부작용의 부를 아닐 부로 생각했다.
>   * side effect는 '원래 용도 혹은 목적의 효과 외에, 부수적으로 다른 효과가 있는 것'을 뜻한다.
>   * 결국 side effect는 렌더링 외에 실행해야 하는 부수적인 코드들을 말한다.
>   * 예를 들면 네트워크 리퀘스트, DOM 수동 동작, 로킹 혹은 정리(clean - up)가 필요 없는 경우들을 말한다.
>   * useEffect()함수는 다음과 같이 사용한다.
>   * 첫번째 파라미터는 이펙트 함수가 들어가고, 두번째 파라미터는 의존성 배열이 들어간다.<br>
``` useEffect(이펙트 함수, 의존성 배열);```
>   * 의존성 배열은 이펙트가 의존하고 있는 배열로, 배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때 이펙트 함수가 실핸된다.
>   * 이펙트 함수는 처음 컴포넌트가 렌더링 된 이후, 그리고 재 렌더링 이후에 실행된다.
>   * 만약 이펙트 함수가 마운트와 언마운트 될 때만 한 번씩 실행되게 하고 싶다면, 빈 배열을 넣으면 된다. 이 경우 props나 state에 있는 어떤 값에도 의존하지 않기 때문에 여러 번 실행되지 않는다.
>   * 의존성 배열을 생략하는 경우에는 업데이트 될 때마다 호출된다.
>   * 정리하면 다음과 같다.
```javascript
useEffect(() => {
    //컴포넌트가 마운트 된 이후
    //의존성 배열에 있는 변수들 중 하나라도 같이 변경 되었을 때 실행됨
    //의존성 배열에 빈 배열([])을 넣으면 마운트와 언마운트시에 단 한 번씩만 실행됨
    //의존성 배열 생략 시 컴포넌트 업데이트 시마다 실행됨

    return () => {
        //컴포넌트가 마운트 해제되기 전에 실행됨
    }
}
), [의존성 변수1, 의존성 변수2, ...]
```
> * ### 7.4 useMemo
>   * useMemo() 혹은 Memoizde value를 리턴하는 훅이다.
>   * 이전 계산 값을 갖고 있기 때문에 연산량이 많은 작업의 반복을 피할 수 있다.
>   * 이 훅은 렌더링이 일어나는 동안 실행된다.
>   * 따라서 렌더링이 일어나는 동안 실행돼서는 안될 작업을 넣으면 안된다.
>   * 예를 들면 useEffect에서 실행되어야 할 사이드 이펙트 같은 것이다.

2. 2교시
```javascript
const memoizedValue = useMemo(
    () => {
        //연산량이 높은 작업을 수행하여 결과를 반환
        return computeExpensiveValue(의존성 변수1, 의존성 변수2);
    },
    [의존성 변수1, 의존성 변수2]
)
```
>   * 다음 코드와 같이 의존성 배열을 넣지 않을 경우, 렌더링이 일어날 때마다 매번 함수가 실행된다.
>   * 따라서 의존성 배열을 넣지 않는 것은 의미가 없다.
>   * 만약 빈 배열을 넣게 되면 컴포넌트 마운트 시에만 함수가 실행된다.
```javascript
const memoizedValue = useMemo(
    () => computeExpensiveValue(a, b)
);
```
> * ### 7.5 useCallback
>   * useCallback() 훅은 useMemo()와 유사한 역할을 합니다.
>   * 차이점은 값이 아닌 함수를 반환한다는 점이다.
>   * 의존성 배열을 파라미터로 받는 것은 useMemo()와 동일하다.
>   * 파라미터로 받은 함수를 콜백이라고 부른다
>   * useMemo와 마찬가지로 의존성 배열 중 하나라도 변경되면 콜백함수를 반환한다
```javascript
const memoizedCallback = useCallback(
    () => {
        doSomething(의존성 변수1, 의존성 변수2)
    },
    [의존성 변수1, 의존성 변수2]
);
```
> * ### 7.6 useRef
>   * useRef() 훅은 레퍼런스를 사용하기 위한 훅이다.
>   * 레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미한다.
>   * useRef() 훅은 바로 이 레퍼런스 객체를 반호나한다,
>   * 레퍼런스 객체에는 .current라는 속성이 있는데, 이것은 현재 참조하고 있는 엘리먼트를 의미한다.
```javascript
        const refContainer = useRef(초깃값);
```
>   * 이렇게 반환된 레퍼런스 객체는 컴포넌트의 라이프타임 전체에 걸쳐서 유지된다.
>   * 즉, 컴포넌트가 마운트 해제 전까지는 계속 유지된다는 의미다.
> * ### 7.7 훅의 규칙
>   * 첫 번째 규칙은 무조건 최상의 레벨에서만 호출해야 한다는 것이다. 여기서 최상위는 컴포넌트의 최상위 레벨을 의미한다.
>   * 따라서 반복문이나 조건문 또는 중첩된 함술들 안에서 훅을 호출하면 안된다.
>   * 이 규칙에 따라서 훅은 컴포넌트가 렌더링 될 때마다 같은 순서로 호출되어야 한다.
>   * 페이지 224의 코드는 조건에 따라 호출됨으로 잘못된 코드다.
>   * 두번째 규칙은 리액트 함수형 컴포넌트에서만 훅을 호출해야 한다는 것이다.
>   * 따라서 일반 자바스크립트 함수에서 훅을 호출하면 안된다.
>   * 훅은 리액트의 함수형 컴포넌트 혹은 직접 만든 커스텀 훅에서만 호출 할 수 있다.
> * ### 7.8 나만의 훅 만들기
>   * 필요하다면 직접 훅을 만들어 쓸 수도 있다. 이 것을 커스텀 훅이라고 한다.
> * #### 1. 커스텀 훅을 만들어야 하는 상황
>   * 예제 UserStatus 컴포넌트는 isOnline이라는 state에 따라서 사용자의 상태가 온라인인지 아닌지를 텍스트로 보여주는 컴포넌트다.
```javascript
import React, { useState, useEffect } from "react";

function UserStatus(props) {
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
        function handleStatusChange(status) {
            setIsOnline(status.isOnline);
        }

        ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
        return () => {
            ServerAPI.unsubscribeUserStatus(props.user.id, handleStatusChange);
        }
    });

    if (isOnline === null) {
        return '대기중...';
    }

    return isOnline ? '온라인' : '오프라인';
}
```
> * #### 2. 커스텀 훅 추출하기
>   * 두 개의 자바스크립트 함수에서 하나의 로직을 공유하도록 하고 싶을 때 새로운 함수를 하나 만드는 방법을 사용한다.
>   * 리액트 컴포넌트와 훅은 모두 함수이기 때문에 동일한 방법을 사용 할 수 있다.
>   * 이름을 use로 시작하고, 내부에서 다른 훅을 호출하는 자바스크립트 함수를 만들면 된다.
>   * 한 가지 주의 할 점은 일반 컴포넌트와 마찬가지로 다른 훅을 호출하는 것은 무조건 커스텀 훅의 최상위 레벨에서만 해야한다.
>   * 커스텀 훅은 일반 함수와 같다고 생각해도 된다.
>   * 다만 이름은 use로 시작하도록 한다는 것만 다르다.
> * #### 3. 커스텀 훅 사용하기

3. 3교시
> * ### 7.9 (실습) 훅을 사용한 컴포넌트 개발 (chapter_07 폴더에 있는 useCounter.jsx, Accommodate.jsx 파일 참조)

## 2023.04.06 6주차<br>
1. 1교시
> * ### 5.5 컴포넌트 추출
>   * 복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 나눌 수도 있다.
>   * 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것이다. <br><br> p.s. 실무에서는 처음부터 1개의 컴포넌트에 하나의 기능만 사용하도록 설계하는것이 좋다.
>   * Comment는 댓글 표시 컴포넌트다.
>   * 내부에는 이미지, 이름, 댓글과 작성일이 포함되어 있다.
>   * 첫 번째로 이미지 부분을 Avater 컴포넌트로 추출
```javascript 
function Avater(props) {
    return (
        <img className = "avater"
            src = {props.user.avaterUrl}
            alt = {prop.user.name}
        />
    );
}
```
>   * 두 번째로 사용자 정보 부분을 추출
>   * 컴포넌트 이름은 UserInfo로 한다. 
>   * UserInfo 안에 Avater 컴포넌트를 넣어서 완성시키기
```javascript
function UserInfo(props) {
    return (
        <div className="user-info">
            <Avater user={props.user} />
            <div className="user-info-name">
                {props.user.name}
            </div>
        </div>
    );
}
```
>   * 추출 후 다시 결합한 UserInfo를 Comment 컴포넌트에 반영하면 다음과 같은 모습이 된다.
>   * 처음에 비해 가독성이 높아진 것을 확인 가능
```javascript
function Comment(props) {
    return (
        <div className = "comment">
            <UserInfo user={props.author} />
            <div className="comment-text">
                {props.text}
            </div>
            <div className="comment-date">
                {formatDate(props.date)}
            </div>
        </div>
    );
}
```
> * ### 5.6 (실습) 댓글 컴포넌트 만들기 (chapter_05 Comment.jsx 참조)
>   * 프로젝트 디렉토리에 /src/chapter_05 디렉토리를 새로 생성
>   * 그 안에 Comment.jsx라는 파일 생성
>   * Comment 컴포넌트 만들기
>   * 그 다음 CommentList.js를 생성, 컴포넌트를 다음과 같이 코딩
>   * CommentList를 렌더링하기 위해 index.js를 다음과 같이 수정
>   * 4장에서 사용했던 setInterval(() => {}, 1000) 부분은 삭제
>   * `<Clock />`을 `<CommentList />`로 수정.
>   * Comment 컴포넌트에 css를 다음과 같이 작성
>   * 다음으로 Comment에 style을 적용할 수 있도록 다음과 같이 수정

2. 2교시
>   * 이번에는 Comment를 범용으로 사용 할 수 있도록 이름과 코멘트를 props로 받도록 수정
>   * props로 전달받은 것이 없어서 아무 것도 출력되지 않음
>   * 이렇게 코드를 작성하면 매번 컴포넌트를 수정해야 하기 때문에 나쁜 코드의 예다.
>   * 별도의 객체로 받아 컴포넌트에서 분리하여 출력하도록 해야 한다.
>   * 이때 사용하는 함수가 map() 함수다.
> * ### 6.1 state
> * #### 1. State란?
>   * State는 리액트 컴포넌트의 상태를 의미한다.
>   * 상태의 의미는 정상인지 비정상인지가 아니라 컴포넌트의 데이터를 의미한다.
>   * 정확히는 컴포넌트의 변경가능한 데이터를 의미한다.
>   * State가 변하면 다시 렌더링이 되기 때문에 렌더링과 관련된 값만 state에 포함시켜야 한다.
> * #### 2.state의 특징
>   * 리액트 만의 특별한 형태가 아닌 단지 자바스크립트 객체일 뿐이다.
>   * 예의 LikeButton은 class 컴포넌트다.
>   * constructor는 생성자이고 그 안에 있는 this.state가 현 컴포넌트의 state다.
```javascript
class LikeButton extends React.Component {
    constructor(props) {
        super(props);

        this.state = (
            liked: false
        );
    }
}
```
>   * 함수형에서는 useState()라는 함수를 사용한다.
>   * state는 변경 가능하다고 했지만 직접 수정해서는 안된다.
>   * 불가능하다고 생각하는 것이 좋다.
>   * state를 변경하고자 할 때에는 setstate()함수를 사용한다.

3. 3교시
> * ### 6.2 생명주기에 대해 알아보기
>   * 생명주기는 컴포넌트의 생성 시점, 사용 시점, 종료 시점을 나타내는 것이다.
>   * constructor가 실행되면서 컴포넌트가 생성된다
>   * 생성 직후 componentDidMount()함수가 호출된다.
>   * 컴포넌트가 소멸하기 전까지 여러 번 렌더링 한다.
>   * 렌더링은 props, setState(), forceUpdate()에 의해 상태가 변경되면 이루어진다.
>   * 렌더링이 끝나면 commponentDinUpdate() 함수가 호출된다.
>   * 컴포넌트가 언마운트 되면 componentWillUnmount()함수가 호출된다.
> * ### 6.3 (실습) state와 생명주기 함수 사용하기 (실습은 파일 참조)
> * #### 2. (실습) React Developer Tools 설치
>   * 구글에서 'React Developer Tools'로 검색하면 찾을 수 있다.
>   * 스폰서 링크 때문에 교재처럼 맨 위에 오지 않을 수 있다.
>   * 링크를 클릭하면 'chrome 웹 스토어'로 이동된다.
>   * 'Chrome에 추가'버튼을 클릭해서 설치한다.




## 2023.03.30 5주차<br>
1. 1교시
> * ### 4.1 엘리먼트에 대해 알아보기
>   * 엘리먼트는 리액트 앱을 굿어하는 요소를 의미한다.
>   * 공식페이지에는 "엘리먼트는 리액트 앱의 가장 작은 빌딩 블록"이라고 설명
>   * 웹사이트 의 경우는 DOM 엘리먼트이며 HTML요소를 의미한다.
>   * 리액트 엘리먼트와 DOM엘리먼트의 차이점
>       * 리액트 엘리먼트는 Virtual DOM의 형태를 취하고 있다.
>       * DOM 엘리먼트는 페이지의 모든 정보를 가지고 있어 무겁다.
>       * 리액트 엘리먼트는 변화한 부분만 가지고 있어 가볍다.
> * #### 1. 엘리먼트의 생김새
>   * 리액트 엘리먼트는 자바스크립트 객체의 형태로 존재한다.
>   * 컴포넌트(Button 등), 속성(color 등) 및 내부의 모든 children을 포함하는 일반 JS객체다.
>   * 이 객체는 마음대로 변경 할 수 없는 불변성을 갖고 있다.
>   * 리액트 엘리먼트의 예를 보면 type에 태그 대신 리액트 컴포넌트가 들어가 있는 것 외에는 차이가 없다.
>   * 자바 스크립트 객체다.
>   * 내부적으로 자바 스크립트 객체를 만드는 역할을 하는 함수는 createElement()다.
>       * 첫 번째 매개변수가 type다. 이 곳에 태그가 들어가면 그대로 표현하고, 만일 리액트 컴포넌트가 들어가면 이 것을 분해해 결국 태그로 만들게 된다.
>       * 두 번째 매개변수인 props는 속성을 나타낸다
>       * 세 번째 매겨변수는 children이다.
> * #### 2. 엘리먼트의 특징
>   * 리액트 엘리먼트의 가장 큰 특징은 불변성이다
>   * 한 번 생성된 엘리먼트의 children이나 속성을 바꿀 수 없다.
>   * 만약 내용이 바뀐다면?
>       * 컴포넌트를 통해 새로운 엘리먼트를 생성해야 한다.
>       * 그 다음 이전 엘리먼트와 교체하는 방법으로 내용을 바꾸는 것
>       * 교체하는 작업을 하기 위해 Virtual DOM을 사용합니다.
> * ### 4.3 랜더링 된 엘리먼트 업데이트하기
>   * 다음 코드는 tick() 함수를 정의하고 있다.
>   * 이 함수는 현재 시간을 포함한 element를 생성하여 root div에 렌더링해 준다.
>   * 라인 12번을 보면 setInterval()함수를 이용해서 정의한 tick()을 1초에 한번씩 호출하고 있다.
>   * 결국 1초에 한번씩 element를 새로 만들고 그 것을 교체하는 것이다.
>   * 다음 코드를 실행하고 크롬 개발자도구에서 확인해 보면 시간 부분만 업데이트 되는 것을 확인 할 수 있다.

2. 2교시
> * ### 4.3 랜더링 된 엘리먼트 업데이트하기
>   * clock.html 만들기
> * ### 4.4 (실습) 시계 만들기
>   1. 이전에 만들었던 프로젝트 디렉토리를 오픈
>   2. chapter_04라는 디렉토리를 생성 
>   3. 디렉토리 안에 Clock.jsx라는 이름으로 파일을 생성
>   4. Clock 컴포넌트 만들기
>   5. 다음 index.js를 수정하여 1초에 한번씩 Clock 컴포넌트를 root div에 렌더링하도록 한다.

3. 3교시
> * ### 5.1 컴포넌트에 대해 알아보기
>   * 2장에서 설명한 바와 같이 리액트는 컴포넌트 기반의 구조를 갖는다.
>   * 컴포넌트 구조라는 것은 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고, 다시 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는 것을 의미한다.
>   * 컴포넌트 재사옹이 가능하기 때문에 전체 코드의 양을 줄일 수 있어 개발 시간과 유지 보수 비용도 줄일 수 있다.
>   * 컴포넌트는 자바스크립트 함수와 입력과 출력이 있다는 면에서는 유사하다.
> ### 5.2 Props에 대해 알아보기
> #### 1. Props의 개념
>   * props는 prop(property : 속성, 특성)의 준말이다.
>   * 이 props가 바로 컴포넌트의 속성이다.
>   * 컴포넌트에 어떤 속성, props를 넣느냐에 따라서 속성이 다른 엘리먼트가 출력된다.
>   * props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체다.
> #### 2. Props의 특징
>   * 읽기 전용이다. 변경 할 수 없다는 의미
>   * 속성이 다른 엘리먼트를 생성하려면 새로운 props를 컴포넌트에 전달하면 된다.
>   * Pure 함수 vs Impure 함수
>       * Pure 함수는 인수로 받은 정보가 함수 내부에서도 변하지 않는 함수
>       * Impure 함수는 인수로 받은 정보가 함수 내부에서 변하는 함수
> #### 3. Props의 사용법
>   * JSX에서는 key-value쌍으로 props를 구성한다
>   * JSX를 사용하지 않는 경우 props의 전달 방법은 createElement() 함수를 사용하는 것이다.
> * ### 5.3 컴포넌트 만들기
> * #### 1. 컴포넌트의 종류
>   * 리액트 초기버전을 사용할 때에는 클래스형 컴포넌트를 주로 사용했다.
>   * 이후 Hook이라는 개념이 나오면서 최근에는 함수영 컴포넌트를 주로 사용한다.
>   * 예전에 작성된 코드난 문서들이 클래스형 컴포넌트를 사용하고 있기 때문에 클래스형 컴포넌트와 컴포넌트의 생명주기에 관해서도 공부해 두어야 한다.
> * #### 2. 함수형 컴포넌트
>   * Welcome컴포넌트는 props를 받아, 받은 props중 name키의 값을 "안녕," 뒤에 넣어 반환<br><br>
        `function Welcome(props) {`<br>`
           return <h1>안녕, {props.name}</h1>;`<br>`
        }`
> * #### 3. 클래스형 컴포넌트
>   * Welcome컴포넌트는 React.Commponent class로 부터 상속을 받아 선언<br><br>
        `class Welcome extends React.Componenet {`<br>`
            render() {`<br>`
                return <h1>안녕, {this.props.name}</h1>;
            }`<br>`
        }`
> * #### 4. 컴포넌트 이름 짓기
>   * 이름은 항상 대문자로 시작
>   * 리액트는 소문자로 시작하는 컴포넌트를 DOM 태그로 인식하기 때문
>   * 컴포넌트 파일 이름과 컴포넌트 이름은 같게 설정

> * ### 5.4 컴포넌트 합성
>   * 컴포넌트 합성은 여러 개의 컴포넌트를 합쳐서 하나의 컴포넌트를 만드는 것
>   * 리액트에서는 컴포넌트 안에 또 다른 컴포넌트를 사용할 수 있기 때문에 복잡한 화면을 여러개의 컴포넌트로 나누어 구현할 수 있다.

## 2023.03.23 4주차<br>
1. 1교시<br>

> * ### 새 프로젝트 만들기 
>   1. README.md 백업
>   2. 23-react1 폴더 삭제/이름변경
>   3. 새 프로젝트 생성(23-react1)
>   4. GITHUB 저장소 삭제
>   5. 23-react1 push
>   6. GITHUB 저장소 확인
>   7. README.md 파일 복원
>   8. create-react-add 23-react1 및 npm start

2. 2교시<br>

> * ### 3.1 JSX란?
>   * JavaScript에 XML을 추가한 확장 언어다.
> * ### 3.2 JSX의 역할
>   * JSX는 내부적으로 XML/HTML 코드를 자바 스크립트로 변환한다.
>   * React가 createElement함수를 사용하여 자동으로 자바스크립트로 변환해준다.
>   * 만일 JS작업할 경우 직접 createElement함수를 사용해야 한다.
>   * JSX는 가독성을 높여주는 역할을 한다.
> * ### 3.3 JSX의 장점
>   * 코드가 간결해 진다.
>   * 가독성이 향상 된다.
>   * Injection Attack이라 불리는 해킹 방법을 벙어함으로써 보안에 강하다.

3. 3교시<br> 

> * ### 3.4 JSX 사용법
>   * 모든 자바스크립트 문법을 지원한다
>   * 자바스크립트 문법에 XML과 HTML을 섞어서 사용한다.
>   * 만일 HTML이나 XML에 자바스크립트 코드를 사용하고 싶다면 {}괄호를 사용한다.
> * ### 3.5 (실습) JSX 코드 작성해 보기
>   * create-react-app으로 만든 프로젝트를 VSCode로 연다.
>   * src 디렉토리에 'chapter_03'이라는 디렉토리를 생성한다.
>   * 생성한 디렉토리에 Book.jsx라는 파일을 생성한다.
>   * Book.jsx를 생성한 디렉토리에 Library.jsx 파일을 생성한다.
>   * 프로젝트 root의 index.js 파일을 오픈한다.
>   * Library컴포넌트를 import한다.
>   * render 함수에서 App을 Library 컴포넌트로 수정한다
>   * npm start로 app을 실행하고 결과를 확인한다.

## 2023.03.16 3주차<br>
1. 1교시<br>

> * ### 0.4 개발 환경 설정하기
>   * node.js 설치하기 <br>(ps. 패키지를 설치 했을때 버전 확인하는 습관을 들여놓기)
>   * node --version (node -v)
>   * npm --version (npm -v)
>   * npx --version (npx -v)
<br>

2. 2교시<br>

> * ### 1.1 리액트는 무엇인가?
>   * 리액트의 정의
>       * 사용자 인터페이스를 만들기 위한 자바스크립트  라이브러리
>       * 라이브러리란?<br>
            자주 사용되는 기능을 정리해 모아 놓은 것
>   * 다양한 자바스크립트 UI 프레임워크
>       * Stack Overflow trands <br>
            (UI 프레임워크를 모아서 어떤 것이 인기가 많은지 보여주는 사이트)
>   * 리액트 개념 정리
>       * 복잡한 사이트를 쉽고 빠르게 만들고, 관리하기 위해 만들어진 것
>       * 다른표현으로는 SPA를 쉽고 빠르게 만들 수 있도록 해주는 도구
> * ### 1.2 리액트의 장점
>   * 빠른 업데이트와 렌더링 속도
>       * 이 것을 가능하게 하는 것이 바로 Virtual DOM이다.
>       * DOM(Document Object Model)이란 XML, HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스. W3C의 표준이다.
>       * Virtual DOM은 DOM 조직이 비효율적인 이유로 속도가 느려서 고안된 방법이다.
>       * DOM은 동기식 Virtual DOM은 비동기식 방법으로 렌더링 한다. <br> (ps. 비동기식이 발전 할 수 있었던 이유는 개발할때 모바일을 먼저 설계한 뒤 데스크탑을 그 다음으로 개발하는 모바일 중심으로 변경되어서(아마도))
>   * 컴포넌트 기반 구조
>       * 리액트의 모든 페이지는 컴포넌트로 구성됨
>       * 하나의 컴포넌트는 다른 여러 개의 컴포넌트의 조합으로 구성 가능
>       * 리액트로 개발 하다 보면 레고 블록을 조립하는 것처럼 컴포넌트를 조합해서 웹사이트를 개발하게 된다.
>       * 이런 방식은 재사용 성이 뛰어나다.
>   * 재사용성
>       * 반복적인 작업을 줄여주기 때문에 생산성을 높여준다.
>       * 유지보수가 용이하다.
>       * 재사용이 가능하려면 해당 모듈의 의존성이 없어야 한다.


3. 3교시<br>
> * ### 1.2 리액트의 장점
>   * 든든한 지원군<br>메타(구 페이스북)에서 오픈소스 프로젝트로 관리하고 있어 계속 발전하고 있다.
>   * 활발한 지식 공유 및 커뮤니티
>   * 모바일 앱 개발 가능
> * ### 1.3 리액트의 단점
>   * 방대한 학습량<br> 자바스크립트를 공부한 경우 빠르게 학습이 가능하다.
>   * 높은 상태 관리 복잡도<br> state, component life cycle 등의 개념이 있지만 그리 어렵지 않다.
> * ### 2.3 (실습) 웹사이트에 React.js 추가하기
>   * 간단한 리액트 컴포넌트를 만든다. like_button.js
>   * 그리고 index.html을 실행한다.
>   * 버튼이 보이는지 확인한다.
>   * 버튼을 누르면 Clicker! 라고 뜨는지 확인한다.
> * ### 2.4 (실습) create - react - app



    

## 2023.03.09 2주차<br>
1교시 : 전 시간에 배웠던 git 연결 및 commit 하는 법 복습 <br>
2교시 : github 아이디를 만들고 vscode와 github와 연결 한 뒤 push를 해서 Repositories에 저장하는 방법을 배움<br>
3교시 : html과 CSS에 대해서, JavaScript의 대해서와 자바스크립트의 자료형(ex/ var, let, const), 연산자(ex/ 대입, 산술, 관계, 비교, 동등, 일치, 이진 논리, 조건부, 삼항), 함수에 대해서 배웠다.
<br><br>





